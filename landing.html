<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>VAEORA – Interactive 3D Landing Scene</title>
    <style>
        html,body{margin:0;padding:0;overflow:hidden;width:100vw;height:100vh;background:#0b1b2a;overscroll-behavior:none}
        canvas{display:block}
        .mouse-wrap{position:absolute;bottom:2rem;left:50%;transform:translateX(-50%);text-align:center;pointer-events:none;z-index:10;color:#6c7a89;font-family:sans-serif;font-size:1.3rem;opacity:.7;user-select:none}
    </style>
</head>
<body>
<div class="mouse-wrap"><div class="mouse"><!-- indicator --></div><p class="mousetext">˅</p></div>

<script src="res/three.js"></script>
<script>
  (() => {
    'use strict';

    /* ===== Core ===== */
    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1b2a, 0.0002);

    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 3.5, 7000);
    camera.position.set(0, 0, 420);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(DPR);
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x0b1b2a, 1);
    document.body.appendChild(renderer.domElement);

    const IS_MOBILE = /Mobi|Android|iPhone|iPad|Touch/.test(navigator.userAgent);
    const COUNT = IS_MOBILE ? 5600 : 7200;

    /* ===== Timing & motion ===== */
    const MORPH_DURATION = 3.3;         // hard max
    const SWIRL_Y = 0.005;             // gentle global swirl
    const CHAOS_AMPL = 0.18;            // tiny shimmer so paths are traceable
    const CHAOS_FREQ = 0.08;
    const TWIST_TURNS = 0.0025;           // circular “ordered” arc (turns around Y)
    const TAIL_LEN = IS_MOBILE ? 40 : 50;
    const TAIL_SUBSAMPLE = IS_MOBILE ? 3 : 2;

    /* ===== SVG paths ===== */
    const logoPath = `M 205.421 116.22 L 236.765 134.869 L 205.429 154.02 L 174.014 134.911 L 205.421 116.22 Z
  M 191.729 134.818 L 205.545 143.256 L 219.294 135.026 L 205.499 127.324 L 191.729 134.818 Z
  M 186.66 172.193 L 186.69 191.82 L 174.001 184.061 L 174.087 164.371 L 186.66 172.193 Z
  M 173.93 143.883 L 205.448 163.421 L 236.93 144.191 L 236.887 155.459 L 205.492 174.879
  L 174.21 155.459 L 173.93 143.883 Z
  M 236.866 164.687 L 236.643 183.781 L 224.178 191.82 L 224.209 172.005 L 236.866 164.687 Z`;

    const textPath = `M 150.425 194.166 L 115.69 119.892 L 128.371 119.892 L 155.554 182.86 L 156.843 182.856
  L 179.672 119.892 L 192.267 119.892 L 161.376 194.166 L 150.425 194.166 Z
  M 249.117 120.733 L 280.797 194.166 L 268.723 194.166 L 239.243 132.273 L 210.244 194.166
  L 197.693 194.166 L 232.436 120.733 L 249.117 120.733 Z
  M 295.337 122.874 L 358.541 122.874 L 358.541 130.195 L 295.337 130.195 L 295.337 122.874 Z
  M 295.337 184.045 L 358.541 184.045 L 358.541 191.363 L 295.337 191.363 L 295.337 184.045 Z
  M 295.337 154.628 L 349.826 154.628 L 349.826 160.294 L 295.337 160.294 L 295.337 154.628 Z
  M 380.481 158.739 C 380.655 146.635 384.38 137.162 391.643 130.325 C 395.402 126.788 403.665 121.266
  417.438 120.344 C 428.734 119.589 436.448 122.877 440.504 125.551 C 446.722 129.655 449.988 132.851
  453.022 138.325 C 456.273 144.198 457.547 150.602 457.444 157.894 C 457.329 165.294 455.584 171.905
  452.214 177.741 C 448.84 183.574 444.118 188.007 438.026 190.989 C 431.941 193.989 425.404 195.492
  418.419 195.492 C 410.842 195.492 404.098 193.841 398.183 190.515 C 392.261 187.196 387.81 182.674
  384.817 176.934 C 381.836 171.201 380.381 165.131 380.481 158.739 Z
  M 388.658 156.676 C 388.002 173.308 399.594 187.915 418.99 187.548 C 438.17 187.185 450.018 176.278
  449.985 156.187 C 449.962 142.528 439.944 127.577 419.616 127.37 C 401.124 127.181 389.354 138.939
  388.658 156.676 Z
  M 606.355 120.559 L 641.453 194.166 L 629.391 194.166 L 599.9 132.273 L 570.964 194.166 L 558.35 194.166
  L 593.378 120.559 L 606.355 120.559 Z
  M 492.883 161.257 L 492.916 194.166 L 480.05 194.166 L 480.242 120.414 L 516.537 120.685 C 521.496 120.722
  525.748 121.029 529.233 122.688 C 532.725 124.351 535.395 126.725 537.243 129.833 C 539.095 132.929
  540.017 136.651 540.021 140.973 C 540.025 146.654 538.343 151.276 534.977 154.835 C 531.607 158.394
  526.729 160.468 520.344 161.061 L 545.965 194.166 L 534.236 194.166 L 512.9 161.427 L 492.883 161.257 Z
  M 492.883 156.039 L 516.559 156.239 C 520.092 156.265 523.003 155.739 525.329 154.654 C 527.633 153.58
  529.377 152.057 530.555 150.109 C 531.736 148.172 532.329 145.961 532.321 143.473 L 532.325 138.473
  C 532.325 135.988 531.736 133.766 530.558 131.799 C 529.381 129.84 527.633 128.307 525.322 127.184
  C 523.007 126.07 520.085 125.496 516.555 125.473 L 492.883 125.27 L 492.883 156.039 Z`;

    /* ===== Helpers ===== */
    function sampleSvg(pathStr, n){
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', pathStr.trim()); svg.appendChild(path); document.body.appendChild(svg);
      const len = path.getTotalLength(); const pts=[];
      for(let i=0;i<n;i++){ const pt=path.getPointAtLength((i/(n-1))*len); pts.push({x:pt.x,y:-pt.y,z:0}); }
      document.body.removeChild(svg); return pts;
    }
    function centerScaleToRadius(pts, desiredR){
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
      for(const p of pts){ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
      const cx=(minX+maxX)/2, cy=(minY+maxY)/2; const half=Math.max(maxX-minX,maxY-minY)/2||1;
      const s=desiredR/half;
      return pts.map(p=>({x:(p.x-cx)*s,y:(p.y-cy)*s,z:0}));
    }
    function addDepthStable(pts, depth=60){
      return pts.map((p,i)=>({x:p.x,y:p.y,z:(Math.sin(i*3.9898+0.5)*43758.5453 % 1 - 0.5)*2*depth}));
    }
    function boundsOf(arrs){
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,minZ=Infinity,maxZ=-Infinity;
      for(const arr of arrs)for(const p of arr){
        if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x;
        if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y;
        if(p.z<minZ)minZ=p.z; if(p.z>maxZ)maxZ=p.z;
      }
      return {minX,maxX,minY,maxY,minZ,maxZ};
    }
    function interleave10(n){ n=(n|(n<<16))&0x030000FF; n=(n|(n<<8))&0x0300F00F; n=(n|(n<<4))&0x030C30C3; n=(n|(n<<2))&0x09249249; return n; }
    function mortonOrder(points, b){
      const nx=1/((b.maxX-b.minX)||1), ny=1/((b.maxY-b.minY)||1), nz=1/((b.maxZ-b.minZ)||1);
      return points.map((p,i)=>{
        const xi=Math.max(0,Math.min(1023,((p.x-b.minX)*nx*1023)|0));
        const yi=Math.max(0,Math.min(1023,((p.y-b.minY)*ny*1023)|0));
        const zi=Math.max(0,Math.min(1023,((p.z-b.minZ)*nz*1023)|0));
        return {i, key:(interleave10(xi)|(interleave10(yi)<<1)|(interleave10(zi)<<2))};
      }).sort((a,b)=>a.key-b.key).map(o=>o.i);
    }
    function reorderBy(order, pts){ const out=new Array(order.length); for(let k=0;k<order.length;k++) out[k]=pts[order[k]]; return out; }

    // Circular arc tween (ordered, traceable):
    // move from a→b along an arc around Y by TWIST_TURNS turns; small per-particle sign to avoid total coherence
    function arcTween(a, b, u, idx){
      // cylindrical coords
      const ra = Math.hypot(a.x, a.z)+1e-6, thea = Math.atan2(a.z, a.x);
      const rb = Math.hypot(b.x, b.z)+1e-6, theb = Math.atan2(b.z, b.x);
      const ya = a.y, yb = b.y;
      // base interp
      const r = ra + (rb - ra)*u;
      const y = ya + (yb - ya)*u;
      // extra twist for visible circular paths
      const sgn = ((idx*1.37)%2) < 1 ? 1 : -1;
      const twist = sgn * (TWIST_TURNS*2*Math.PI) * u*(1-u); // bell-shaped
      // angle interpolation (shortest + twist)
      let dth = theb - thea;
      if (dth > Math.PI) dth -= 2*Math.PI; else if (dth < -Math.PI) dth += 2*Math.PI;
      const th = thea + dth*u + twist;
      return { x: r*Math.cos(th), y, z: r*Math.sin(th) };
    }

    /* ===== Build targets (stable mapping) ===== */
    const desiredShapeRadius = 220; // keeps SVG fully on-screen
    const text3D = addDepthStable(centerScaleToRadius(sampleSvg(textPath, COUNT), desiredShapeRadius*0.65), 6);
    const logo3D = addDepthStable(centerScaleToRadius(sampleSvg(logoPath, COUNT), desiredShapeRadius*0.5), 7);
    const cloud3D = Array.from({length:COUNT}, (_,i)=>{
      const r = 300 + ((Math.sin(i*7.13+1.7)*0.5+0.5)*220);
      const a = (i*0.987)%(Math.PI*2), b = (i*1.113)%Math.PI;
      return { x:r*Math.sin(b)*Math.cos(a), y:r*Math.cos(b)*0.75, z:r*Math.sin(b)*Math.sin(a) };
    });

    const gb = boundsOf([text3D, logo3D, cloud3D]);
    const order = mortonOrder(text3D, gb);
    const TEXT  = reorderBy(order, text3D);
    const LOGO  = reorderBy(order, logo3D);
    const CLOUD = reorderBy(order, cloud3D);
    const TARGETS = [TEXT, CLOUD, LOGO];

    /* ===== Geometry / state ===== */
    function discTexture(size=64){
      const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
      const grd=g.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
      grd.addColorStop(0,'rgba(255,255,255,.9)'); grd.addColorStop(.6,'rgba(255,255,255,.7)'); grd.addColorStop(1,'rgba(255,255,255,0)');
      g.fillStyle=grd; g.beginPath(); g.arc(size/2,size/2,size/2,0,Math.PI*2); g.fill();
      const t=new THREE.Texture(c); t.needsUpdate=true; t.minFilter=THREE.LinearMipMapLinearFilter; t.magFilter=THREE.LinearFilter; return t;
    }
    const discTex = discTexture(128);
    const PALETTE = ['#ffb25a','#ff6aa6','#5ad1ff','#9cff8c','#c9d6ff'].map(c=>new THREE.Color(c));

    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT*3);
    const col = new Float32Array(COUNT*3);
    const baseCol = new Float32Array(COUNT*3);
    const chaosPhase = new Float32Array(COUNT);
    const chaosAxis = new Array(COUNT);

    // start on TEXT
    for (let i=0;i<COUNT;i++){
      const p = TEXT[i];
      pos[3*i]=p.x; pos[3*i+1]=p.y; pos[3*i+2]=p.z;
      const bc = PALETTE[(Math.random()*PALETTE.length)|0].clone();
      const h={h:0,s:0,l:0}; bc.getHSL(h);
      bc.setHSL((h.h+(Math.random()-0.5)*0.02+1)%1, h.s, THREE.MathUtils.clamp(h.l+(Math.random()-0.5)*0.1,0,1));
      baseCol[3*i]=bc.r; baseCol[3*i+1]=bc.g; baseCol[3*i+2]=bc.b;
      col[3*i]=bc.r; col[3*i+1]=bc.g; col[3*i+2]=bc.b;
      chaosPhase[i]=Math.random()*Math.PI*2;
      const a=Math.random()*Math.PI*2; chaosAxis[i]=new THREE.Vector3(Math.cos(a),Math.sin(a*1.3),Math.cos(a*0.7)).normalize();
    }
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    geom.setAttribute('color', new THREE.BufferAttribute(col,3));

    const mat = new THREE.PointsMaterial({
      size: IS_MOBILE ? 1.3 : 2.3, map: discTex, transparent:true, alphaTest:0.10, opacity: 0.85,
      depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:true
    });
    const points = new THREE.Points(geom, mat);

    const group = new THREE.Group();
    group.add(points);
    scene.add(group);

    /* ===== Tails (dataveyes-like, fading) ===== */
    const trails = Array.from({length:COUNT}, ()=>[]);
    const tailGeom = new THREE.BufferGeometry();
    const MAX_SEG = Math.ceil(COUNT/TAIL_SUBSAMPLE)*(TAIL_LEN-1);
    const tailPos = new Float32Array(MAX_SEG*6);
    const tailCol = new Float32Array(MAX_SEG*6);
    tailGeom.setAttribute('position', new THREE.BufferAttribute(tailPos,3));
    tailGeom.setAttribute('color', new THREE.BufferAttribute(tailCol,3));
    const tailMat = new THREE.LineBasicMaterial({ vertexColors:true, transparent:true, opacity:0.12, blending:THREE.AdditiveBlending, depthWrite:false });
    const tailLines = new THREE.LineSegments(tailGeom, tailMat);
    group.add(tailLines);

    /* ===== Pointer highlight (colour-only) ===== */
    const pointerNDC = {x:10,y:10}; let pointerPulse = 0;
    const tmpV = new THREE.Vector3();
    function setPointer(x,y){
      const r = renderer.domElement.getBoundingClientRect();
      pointerNDC.x = ((x - r.left)/r.width)*2 - 1;
      pointerNDC.y = -((y - r.top )/r.height)*2 + 1;
      pointerPulse = 1.2;
    }
    addEventListener('mousemove', e=>setPointer(e.clientX,e.clientY));
    addEventListener('touchmove', e=>{ if(e.touches?.length){ const t=e.touches[0]; setPointer(t.clientX,t.clientY);} }, {passive:true});

    /* ===== Morph control ===== */
    let currentTargetIdx = 0;                // 0=text, 1=cloud, 2=logo
    let morphStart = performance.now();
    let srcSnapshot = TEXT;                  // snapshot at start of morph
    function setTarget(idx){
      currentTargetIdx = idx;
      morphStart = performance.now();
      // snapshot current rendered positions as morph sources (prevents bumps)
      srcSnapshot = Array.from({length:COUNT}, (_,i)=>({ x:pos[3*i], y:pos[3*i+1], z:pos[3*i+2] }));
    }
    function cycle(){ setTarget((currentTargetIdx+1)%3); }
    addEventListener('click', cycle);
    addEventListener('touchstart', e=>{ e.preventDefault(); cycle(); }, {passive:false});
    setTimeout(()=>{ if(currentTargetIdx===0) setTarget(1); }, 5000); // auto text→cloud

    /* ===== Resize ===== */
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ===== Easing ===== */
    const easeInOutCubic = x => x<0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2,3)/2;

    /* ===== Animate ===== */
    let time = 0;
    function animate(){
      requestAnimationFrame(animate);
      time += 1/60;

      // subtle, consistent swirl
      group.rotation.y += SWIRL_Y;

      // morph progress 0..1
      const u = Math.min((performance.now()-morphStart)/1000 / MORPH_DURATION, 1);
      const p = easeInOutCubic(u);
      const chaos = CHAOS_AMPL * Math.sin(Math.PI*p);

      const dst = TARGETS[currentTargetIdx];

      // arc-based ordered morph (traceable, circular)
      for (let i=0;i<COUNT;i++){
        const a = srcSnapshot[i];
        const b = dst[i];

        // small shape spin during morph (kept gentle)
        let bb = b;
        if (currentTargetIdx !== 1) {
          const s = time*0.025;
          const c = Math.cos(s), sN = Math.sin(s);
          bb = { x: b.x*c - b.z*sN, y: b.y, z: b.x*sN + b.z*c };
        }

        const m = arcTween(a, bb, p, i);

        // tiny shimmer (no jumps)
        const jit = chaos * Math.sin(CHAOS_FREQ*time + chaosPhase[i]);
        m.x += chaosAxis[i].x * jit;
        m.y += chaosAxis[i].y * jit;
        m.z += chaosAxis[i].z * jit;

        pos[3*i] = m.x; pos[3*i+1] = m.y; pos[3*i+2] = m.z;

        // base color + pointer halo
        let r=baseCol[3*i], g=baseCol[3*i+1], bcol=baseCol[3*i+2];
        tmpV.set(m.x,m.y,m.z).applyMatrix4(group.matrixWorld).project(camera);
        const dx=tmpV.x-pointerNDC.x, dy=tmpV.y-pointerNDC.y;
        const halo = pointerPulse * Math.exp(-(dx*dx+dy*dy)/(2*0.12*0.12));
        if (halo>0.0005){ const mix=0.55*halo; r=r*(1-mix)+1*mix; g=g*(1-mix)+1*mix; bcol=bcol*(1-mix)+1*mix; }
        col[3*i]=r; col[3*i+1]=g; col[3*i+2]=bcol;

        // tails history
        const tr = trails[i]; tr.push({x:m.x,y:m.y,z:m.z}); if (tr.length>TAIL_LEN) tr.shift();
      }
      pointerPulse *= 0.92;

      geom.attributes = geom.attributes || {}; // safety
      geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
      geom.setAttribute('color', new THREE.BufferAttribute(col,3));
      geom.attributes.position.needsUpdate = true;
      geom.attributes.color.needsUpdate = true;

      // update tails (subsampled)
      let seg=0;
      for (let i=0;i<COUNT;i+=TAIL_SUBSAMPLE){
        const tr = trails[i];
        for (let j=1;j<tr.length;j++){
          const a=tr[j-1], b=tr[j]; const base=seg*6;
          tailPos[base]=a.x; tailPos[base+1]=a.y; tailPos[base+2]=a.z;
          tailPos[base+3]=b.x; tailPos[base+4]=b.y; tailPos[base+5]=b.z;
          const fa=(j-1)/(tr.length-1), fb=j/(tr.length-1);
          const la = 0.85*(1-fa*0.95), lb = 0.85*(1-fb*0.95);
          tailCol[base]=la; tailCol[base+1]=la; tailCol[base+2]=la;
          tailCol[base+3]=lb; tailCol[base+4]=lb; tailCol[base+5]=lb;
          seg++;
        }
      }
      for (let k=seg*6;k<tailPos.length;k++){ tailPos[k]=0; tailCol[k]=0; }
      tailGeom.attributes.position.needsUpdate = true;
      tailGeom.attributes.color.needsUpdate = true;

      // stable camera with tiny bob
      camera.position.x = 10*Math.cos(time*0.25);
      camera.position.y =  8*Math.sin(time*0.7);
      camera.position.z = 520 + (currentTargetIdx===1 ? (12*Math.sin(time*0.35))*0.4 : 0);
      camera.lookAt(0,0,0);

      renderer.render(scene, camera);
    }
    animate();
  })();
</script>
</body>
</html>