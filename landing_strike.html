<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>VAEORA – Interactive 3D Landing Scene</title>
    <style>
        html,body{margin:0;padding:0;overflow:hidden;width:100vw;height:100vh;background:#0b1b2a;overscroll-behavior:none}
        canvas{display:block}
        .mouse-wrap{position:absolute;bottom:2rem;left:50%;transform:translateX(-50%);text-align:center;pointer-events:none;z-index:10;color:#6c7a89;font-family:sans-serif;font-size:1.3rem;opacity:.7;user-select:none}
    </style>
</head>
<body>
<div class="mouse-wrap"><div class="mouse"><!-- indicator --></div><p class="mousetext">˅</p></div>

<script src="res/three.js"></script>
<script>
  (() => {
    'use strict';

    /* ------ Setup ------ */
    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1b2a, 0.002);
    const camera = new THREE.PerspectiveCamera(90, innerWidth/innerHeight, 0.5, 5000);
    camera.position.set(0, 0, 1220);

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setPixelRatio(DPR);
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x0b1b2a, 0.25);
    document.body.appendChild(renderer.domElement);

    const IS_MOBILE = /Mobi|Android|iPhone|iPad|Touch/.test(navigator.userAgent);
    const COUNT = IS_MOBILE ? 2600 : 5200;
    const MORPH_DURATION = 5.0; // hard cap
    const SWIRL_Y = 0.0018;     // gentle global swirl (no wild lissajous)
    const CHAOS_AMPL = 0.9;     // reduced to keep motion traceable
    const CHAOS_FREQ = 0.12;

    /* ------ SVG paths ------ */
    const logoPath = `M 205.421 116.22 L 236.765 134.869 L 205.429 154.02 L 174.014 134.911 L 205.421 116.22 Z
  M 191.729 134.818 L 205.545 143.256 L 219.294 135.026 L 205.499 127.324 L 191.729 134.818 Z
  M 186.66 172.193 L 186.69 191.82 L 174.001 184.061 L 174.087 164.371 L 186.66 172.193 Z
  M 173.93 143.883 L 205.448 163.421 L 236.93 144.191 L 236.887 155.459 L 205.492 174.879
  L 174.21 155.459 L 173.93 143.883 Z
  M 236.866 164.687 L 236.643 183.781 L 224.178 191.82 L 224.209 172.005 L 236.866 164.687 Z`;

    const textPath = `M 150.425 194.166 L 115.69 119.892 L 128.371 119.892 L 155.554 182.86 L 156.843 182.856
  L 179.672 119.892 L 192.267 119.892 L 161.376 194.166 L 150.425 194.166 Z
  M 249.117 120.733 L 280.797 194.166 L 268.723 194.166 L 239.243 132.273 L 210.244 194.166
  L 197.693 194.166 L 232.436 120.733 L 249.117 120.733 Z
  M 295.337 122.874 L 358.541 122.874 L 358.541 130.195 L 295.337 130.195 L 295.337 122.874 Z
  M 295.337 184.045 L 358.541 184.045 L 358.541 191.363 L 295.337 191.363 L 295.337 184.045 Z
  M 295.337 154.628 L 349.826 154.628 L 349.826 160.294 L 295.337 160.294 L 295.337 154.628 Z
  M 380.481 158.739 C 380.655 146.635 384.38 137.162 391.643 130.325 C 395.402 126.788 403.665 121.266
  417.438 120.344 C 428.734 119.589 436.448 122.877 440.504 125.551 C 446.722 129.655 449.988 132.851
  453.022 138.325 C 456.273 144.198 457.547 150.602 457.444 157.894 C 457.329 165.294 455.584 171.905
  452.214 177.741 C 448.84 183.574 444.118 188.007 438.026 190.989 C 431.941 193.989 425.404 195.492
  418.419 195.492 C 410.842 195.492 404.098 193.841 398.183 190.515 C 392.261 187.196 387.81 182.674
  384.817 176.934 C 381.836 171.201 380.381 165.131 380.481 158.739 Z
  M 388.658 156.676 C 388.002 173.308 399.594 187.915 418.99 187.548 C 438.17 187.185 450.018 176.278
  449.985 156.187 C 449.962 142.528 439.944 127.577 419.616 127.37 C 401.124 127.181 389.354 138.939
  388.658 156.676 Z
  M 606.355 120.559 L 641.453 194.166 L 629.391 194.166 L 599.9 132.273 L 570.964 194.166 L 558.35 194.166
  L 593.378 120.559 L 606.355 120.559 Z
  M 492.883 161.257 L 492.916 194.166 L 480.05 194.166 L 480.242 120.414 L 516.537 120.685 C 521.496 120.722
  525.748 121.029 529.233 122.688 C 532.725 124.351 535.395 126.725 537.243 129.833 C 539.095 132.929
  540.017 136.651 540.021 140.973 C 540.025 146.654 538.343 151.276 534.977 154.835 C 531.607 158.394
  526.729 160.468 520.344 161.061 L 545.965 194.166 L 534.236 194.166 L 512.9 161.427 L 492.883 161.257 Z
  M 492.883 156.039 L 516.559 156.239 C 520.092 156.265 523.003 155.739 525.329 154.654 C 527.633 153.58
  529.377 152.057 530.555 150.109 C 531.736 148.172 532.329 145.961 532.321 143.473 L 532.325 138.473
  C 532.325 135.988 531.736 133.766 530.558 131.799 C 529.381 129.84 527.633 128.307 525.322 127.184
  C 523.007 126.07 520.085 125.496 516.555 125.473 L 492.883 125.27 L 492.883 156.039 Z`;

    /* ------ Helpers (scoped) ------ */
    function sampleSvg(pathStr, n) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', pathStr.trim()); svg.appendChild(path); document.body.appendChild(svg);
      const len = path.getTotalLength(); const pts = [];
      for (let i=0;i<n;i++){ const pt = path.getPointAtLength((i/(n-1))*len); pts.push({x:pt.x,y:-pt.y,z:0}); }
      document.body.removeChild(svg); return pts;
    }
    function centerScaleToRadius(pts, desiredR) {
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
      for (const p of pts){ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
      const cx=(minX+maxX)/2, cy=(minY+maxY)/2; const half=Math.max(maxX-minX,maxY-minY)/2 || 1;
      const s = desiredR/half;
      return pts.map(p=>({x:(p.x-cx)*s, y:(p.y-cy)*s, z:0}));
    }
    function addDeterministicDepth(pts, depth=60){
      // stable per-index depth so morph between shapes is smooth
      return pts.map((p,i)=>({x:p.x, y:p.y, z:(Math.sin(i*6.9898+0.5)*43758.5453 % 1 - 0.5)*2*depth}));
    }
    // Global Morton (Z-order) using shared bounds -> consistent index mapping across targets
    function mortonOrder(points, bounds){
      const {minX,maxX,minY,maxY,minZ,maxZ} = bounds;
      const nx = 1/((maxX-minX)||1), ny = 1/((maxY-minY)||1), nz = 1/((maxZ-minZ)||1);
      return points.map((p,i)=>{
        const xi = Math.max(0, Math.min(1023, ((p.x-minX)*nx*1023)|0));
        const yi = Math.max(0, Math.min(1023, ((p.y-minY)*ny*1023)|0));
        const zi = Math.max(0, Math.min(1023, ((p.z-minZ)*nz*1023)|0));
        const key = interleave(xi) | (interleave(yi)<<1) | (interleave(zi)<<2);
        return {i, key};
      }).sort((a,b)=>a.key-b.key).map(o=>o.i);
      function interleave(n){ n=(n|(n<<16))&0x030000FF; n=(n|(n<<8))&0x0300F00F; n=(n|(n<<4))&0x030C30C3; n=(n|(n<<2))&0x09249249; return n; }
    }
    function boundsOf(arrs){
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,minZ=Infinity,maxZ=-Infinity;
      for (const arr of arrs) for (const p of arr){
        if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x;
        if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y;
        if(p.z<minZ)minZ=p.z; if(p.z>maxZ)maxZ=p.z;
      }
      return {minX,maxX,minY,maxY,minZ,maxZ};
    }
    function reorderBy(orderIdx, pts){ const out = new Array(orderIdx.length); for(let k=0;k<orderIdx.length;k++) out[k]=pts[orderIdx[k]]; return out; }

    /* ------ Targets (with stable index mapping) ------ */
    const desiredShapeRadius = 920; // ensures SVGs are on screen; camera auto-fits further
    const text3D = addDeterministicDepth(centerScaleToRadius(sampleSvg(textPath, COUNT), desiredShapeRadius*0.25), 5);
    const logo3D = addDeterministicDepth(centerScaleToRadius(sampleSvg(logoPath, COUNT), desiredShapeRadius*0.25), 3);
    // deterministic cloud per index (no wrap -> no teleports)
    const cloud3D = Array.from({length:COUNT}, (_,i)=>{
      const r = 300 + ((Math.sin(i*7.13+1.7)*0.5+0.5)*220);
      const a = (i*0.987)% (Math.PI*2), b = (i*1.113)%Math.PI;
      return { x:r*Math.sin(b)*Math.cos(a), y:r*Math.cos(b)*0.75, z:r*Math.sin(b)*Math.sin(a) };
    });

    // global bounds then Morton sort for each set -> consistent pairing
    const gBounds = boundsOf([text3D, logo3D, cloud3D]);
    const order = mortonOrder(text3D, gBounds); // base order
    const textVol = reorderBy(order, text3D);
    const logoVol = reorderBy(order, logo3D);
    const cloudVol = reorderBy(order, cloud3D);

    const TARGETS = [textVol, cloudVol, logoVol];
    let currentTarget = 0;
    let morphStart = performance.now();

    /* ------ Round sprite material + palette ------ */
    function discTexture(size=64){
      const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
      const grd=g.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
      grd.addColorStop(0,'rgba(255,255,255,1)'); grd.addColorStop(.6,'rgba(255,255,255,.7)'); grd.addColorStop(1,'rgba(255,255,255,0)');
      g.fillStyle=grd; g.beginPath(); g.arc(size/2,size/2,size/2,0,Math.PI*2); g.fill();
      const t=new THREE.Texture(c); t.needsUpdate=true; t.minFilter=THREE.LinearMipMapLinearFilter; t.magFilter=THREE.LinearFilter; return t;
    }
    const discTex = discTexture();
    const PALETTE = ['#ffb25a','#ff6aa6','#5ad1ff','#9cff8c','#c9d6ff'].map(c=>new THREE.Color(c));

    /* ------ Geometry, state, tails ------ */
    const pointsGeom = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT*3);
    const col = new Float32Array(COUNT*3);
    const baseCol = new Float32Array(COUNT*3);
    const chaosPhase = new Float32Array(COUNT);
    const chaosAxis = new Array(COUNT);
    // per-particle velocity for smooth (critically damped) motion
    const vel = new Float32Array(COUNT*3);

    const mat = new THREE.PointsMaterial({
      size: IS_MOBILE ? 2.1 : 7, map: discTex, transparent:true, opacity: 0.98,
      depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:true
    });

    // init on TEXT
    for (let i=0;i<COUNT;i++){
      const p = textVol[i];
      pos[3*i]=p.x; pos[3*i+1]=p.y; pos[3*i+2]=p.z;
      const bc = PALETTE[(Math.random()*PALETTE.length)|0].clone();
      const h={h:0,s:0,l:0}; bc.getHSL(h);
      bc.setHSL((h.h+(Math.random()-0.5)*0.02+1)%1, h.s, THREE.MathUtils.clamp(h.l+(Math.random()-0.5)*0.1,0,1));
      baseCol[3*i]=bc.r; baseCol[3*i+1]=bc.g; baseCol[3*i+2]=bc.b;
      col[3*i]=bc.r; col[3*i+1]=bc.g; col[3*i+2]=bc.b;
      chaosPhase[i]=Math.random()*Math.PI*2;
      const a=Math.random()*Math.PI*2; chaosAxis[i]=new THREE.Vector3(Math.cos(a),Math.sin(a*1.3),Math.cos(a*0.7)).normalize();
    }
    pointsGeom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    pointsGeom.setAttribute('color', new THREE.BufferAttribute(col,3));
    const points = new THREE.Points(pointsGeom, mat);

    // group to swirl whole field (stable, no wild camera)
    const group = new THREE.Group();
    group.add(points);
    scene.add(group);

    // tails (lightweight, additive)
    const TAIL_LEN = IS_MOBILE ? 60 : 74;
    const TAIL_SUBSAMPLE = IS_MOBILE ? 4 : 2; // draw tails for every Nth particle
    const trails = new Array(COUNT);
    for (let i=0;i<COUNT;i++) trails[i]=[];
    const tailGeom = new THREE.BufferGeometry();
    const MAX_SEG = Math.ceil(COUNT/TAIL_SUBSAMPLE)*(TAIL_LEN-1);
    const tailPos = new Float32Array(MAX_SEG*6);
    const tailCol = new Float32Array(MAX_SEG*6);
    tailGeom.setAttribute('position', new THREE.BufferAttribute(tailPos,3));
    tailGeom.setAttribute('color', new THREE.BufferAttribute(tailCol,3));
    const tailMat = new THREE.LineBasicMaterial({vertexColors:true, transparent:true, opacity:0.12, blending:THREE.AdditiveBlending, depthWrite:false});
    const tailLines = new THREE.LineSegments(tailGeom, tailMat);
    group.add(tailLines);

    /* ------ Pointer highlight (colour-only, fades) ------ */
    const pointerNDC = {x:10,y:10}; let pointerPulse = 0;
    const tmpV = new THREE.Vector3();
    function setPointer(x,y){
      const r = renderer.domElement.getBoundingClientRect();
      pointerNDC.x = ((x - r.left)/r.width)*2 - 1;
      pointerNDC.y = -((y - r.top )/r.height)*2 + 1;
      pointerPulse = 1.2;
    }
    addEventListener('mousemove', e=>setPointer(e.clientX,e.clientY));
    addEventListener('touchmove', e=>{ if(e.touches?.length){ const t=e.touches[0]; setPointer(t.clientX,t.clientY);} }, {passive:true});

    /* ------ Triggers ------ */
    function setTarget(idx){ currentTarget = idx; morphStart = performance.now(); }
    function cycle(){ setTarget((currentTarget+1)%3); }
    addEventListener('click', cycle);
    addEventListener('touchstart', e=>{ e.preventDefault(); cycle(); }, {passive:false});
    setTimeout(()=>{ if(currentTarget===0) setTarget(1); }, 5000); // auto TEXT→CLOUD

    /* ------ Resize ------ */
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ------ Easing ------ */
    const easeInOutCubic = x => x<0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2,3)/2;

    /* ------ Animation ------ */
    let t = 0;
    function animate(){
      requestAnimationFrame(animate);
      t += 1/60;

      // global subtle swirl (visual flow) – camera mostly stable
      group.rotation.y += SWIRL_Y;

      // morph timing & visibility
      const elapsed = Math.min((performance.now()-morphStart)/1000, MORPH_DURATION);
      const prog = easeInOutCubic(elapsed/MORPH_DURATION);          // 0..1
      const alpha = 1 - Math.exp(- (0.25 + 1.5*prog));              // critically damped step
      const chaos = CHAOS_AMPL * Math.sin(Math.PI*prog);            // off at ends

      // choose current rotated targets (rotate shapes constantly, but gently)
      const spin = t*0.0015; const c=Math.cos(spin), s=Math.sin(spin);
      const tgtArr = currentTarget===0 ? textVol : (currentTarget===2 ? logoVol : cloudVol);

      for (let i=0;i<COUNT;i++){
        const idx = 3*i;
        const srcX = pos[idx], srcY = pos[idx+1], srcZ = pos[idx+2];

        let tx,ty,tz;
        if (currentTarget===1){ // cloud: static target points (no spin)
          const p = tgtArr[i]; tx=p.x; ty=p.y; tz=p.z;
        } else { // shapes: gently spin around Y
          const b = tgtArr[i]; tx = b.x*c - b.z*s; ty = b.y; tz = b.x*s + b.z*c;
        }

        // critically-damped like low-pass (no bumpy overshoot, visible motion)
        const vx = vel[idx], vy = vel[idx+1], vz = vel[idx+2];
        const ax = (tx - srcX) * alpha, ay = (ty - srcY) * alpha, az = (tz - srcZ) * alpha;
        const nvx = vx*0.85 + ax, nvy = vy*0.85 + ay, nvz = vz*0.85 + az;
        vel[idx]=nvx; vel[idx+1]=nvy; vel[idx+2]=nvz;

        let px = srcX + nvx, py = srcY + nvy, pz = srcZ + nvz;

        // subtle shimmer (kept tiny so path remains traceable)
        const ph = chaosPhase[i]; const axv=chaosAxis[i];
        const jit = chaos * Math.sin(t*CHAOS_FREQ + ph);
        px += axv.x * jit; py += axv.y * jit; pz += axv.z * jit;

        pos[idx]=px; pos[idx+1]=py; pos[idx+2]=pz;

        // base color
        let r=baseCol[idx], g=baseCol[idx+1], b=baseCol[idx+2];

        // pointer highlight (gaussian in NDC), fades
        tmpV.set(px,py,pz).applyMatrix4(group.matrixWorld).project(camera);
        const dx = tmpV.x - pointerNDC.x, dy = tmpV.y - pointerNDC.y;
        const halo = pointerPulse * Math.exp(-(dx*dx+dy*dy)/(2*0.12*0.12));
        if (halo>0.0005){ const mix = 0.55*halo; r=r*(1-mix)+1*mix; g=g*(1-mix)+1*mix; b=b*(1-mix)+1*mix; }
        col[idx]=r; col[idx+1]=g; col[idx+2]=b;

        // tails history
        const tr = trails[i]; tr.push({x:px,y:py,z:pz}); if (tr.length>TAIL_LEN) tr.shift();
      }
      pointerPulse *= 0.92;

      pointsGeom.attributes.position.needsUpdate = true;
      pointsGeom.attributes.color.needsUpdate = true;

      // tails update (subsampled), fade head→tail
      let seg=0;
      for (let i=0;i<COUNT;i+=TAIL_SUBSAMPLE){
        const tr = trails[i]; for (let j=1;j<tr.length;j++){
          const a=tr[j-1], b=tr[j]; const base=seg*6;
          tailPos[base]=a.x; tailPos[base+1]=a.y; tailPos[base+2]=a.z;
          tailPos[base+3]=b.x; tailPos[base+4]=b.y; tailPos[base+5]=b.z;
          const fa=(j-1)/(tr.length-1), fb=j/(tr.length-1);
          const la = 0.85*(1-fa*0.95), lb = 0.85*(1-fb*0.95);
          tailCol[base]=la; tailCol[base+1]=la; tailCol[base+2]=la;
          tailCol[base+3]=lb; tailCol[base+4]=lb; tailCol[base+5]=lb;
          seg++;
        }
      }
      for (let k=seg*6;k<tailPos.length;k++){ tailPos[k]=0; tailCol[k]=0; }
      tailGeom.attributes.position.needsUpdate = true;
      tailGeom.attributes.color.needsUpdate = true;

      // camera: stable, slight bob; auto-fit distance to keep SVGs fully on-screen in shape modes
      const radius = desiredShapeRadius; // shapes already scaled; use small bob only
      const camBaseZ = 1300;
      camera.position.x = 12*Math.sin(t*0.00001);
      camera.position.y = 10*Math.cos(t*0.009);
      camera.position.z = camBaseZ + (currentTarget===1 ? 18*Math.sin(t*0.09) : 0); // tiny push/pull in cloud
      camera.lookAt(0,0,0);

      renderer.render(scene, camera);
    }
    animate();
  })();
</script>
</body>
</html>